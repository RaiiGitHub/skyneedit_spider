Node.js进程的“单线程，基于事件循环，非阻塞 IO”模型的理解：
1、它在事件循环中维护了一个事件队列，在每个时间点上，取出队列的事件串行执行。
2、一个事件执行完成，下一个事件才会执行。
3、一个新的事件进入队列，位于队列尾。
4、会从队列头中取出事件执行。
5、所有异步方法的事件回调函数,会按调用先后塞入事件队列。
6、可以在当前事件的下一个事件插入一个新的事件回调函数，process.nextTick(function(){});但是这个事件被插入事件队列头部，所以下一个事件是执行这个插入的事件。
7、队列中所有事件执行完成时，进程退出。
=========================================================
例如：
var reqeust = require('request');
var t = 1;
for(var i = 0; i < 1000; i++){
    reqeust.get('https://www.baidu.com',function(e,r,b){
        for(var j = 0; j < 5000; j++ ){console.log(j)}
        console.log('================get================>',t++);
        if( t == 2)
            process.nextTick(function(){
                console.log('-------------------nextTick-------------');
                for( var k = 0; k < 5000;k++){console.log('::nextTick',k)}
            })
    })
}
event1:执行1000次请求baidu首页，产生1000个异步方法事件，依次进入队列。
event2:执行j=0~4999,t=1的输出
event3:执行nextTick的输出，::nextTick 0~4999
event4~event1002:执行j=0~4999,t=2~1000的输出。
一共有1002个事件，其中一个是入口事件（产生1000个异步方法回调事件），还有一个是使用process.nextTick插入的事件。
==========================================================
所以，如果异步方法中回调事件阻塞了，那么这个node.js线程也就阻塞了，异步方法并不能同时执行，并不是“争夺CPU时间片”，不然就能当作是线程了。
它的异步方法回调事件是“协程”，或者叫“纤程”，它们所在的线程对其序列化，是顺序执行的。
